---
tags: [test,maven,gradle]
projects: [spring-framework,spring-boot]
---
:spring_version: current
:spring_boot_version: 1.5.3.RELEASE
:SpringApplication: http://docs.spring.io/spring-boot/docs/{spring_boot_version}/api/org/springframework/boot/SpringApplication.html
:DirtiesContext: http://docs.spring.io/spring/docs/{spring_version}/javadoc-api/org/springframework/test/annotation/DirtiesContext.html
:toc:
:icons: font
:source-highlighter: prettify
:project_id: gs-testing-web
本指南将帮助您了解创建Spring应用程序的过程。

== 你将做出什么

您将构建一个简单的Spring的应用和并用JUnit测试它。您可能已经知道如何编写和运行应用程序中各个类的单元测试，因此对于本指南，我们将集中讨论使用Spring Test和Spring Boot特性来测试Spring和你的代码代码之间的交互。你将从一个简单地测试应用程序上下文加载成功，并继续测试只是Web层使用Spring的`MockMvc`。

== 你需要什么

:java_version: 1.8
include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/prereq_editor_jdk_buildtools.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/how_to_complete_this_guide.adoc[]


include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-gradle.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-maven.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-sts.adoc[]



[[initial]]
== 创建一个简单的应用

为你的Spring应用程序创建一个新控制器：

`src/main/java/hello/HomeController.java`
[source,java]
----
include::complete/src/main/java/hello/HomeController.java[]
----

NOTE: 以上例子不指定 `GET` 和 `PUT`, `POST` 等等，因为 `@RequestMapping` 默认映射所有的HTTP操作。使用 `@RequestMapping(method=GET)` 缩小这种映射。


== 使应用程序可执行

虽然可以将此服务打包为一个传统的 link:/understanding/WAR[WAR] 文件用于部署到外部应用服务器，更为简单的方法是创建了一个独立的应用程序。通过一个 good old Java `main()`方法，你能将一切打包成为一个单一的克执行 JAR 文件。在这一过程中，您使用Spring的提供的 link:/understanding/Tomcat[Tomcat]  servlet容器作为HTTP运行时，而不是将它部署的到一个外部实例在中。


`src/main/java/hello/Application.java`
[source,java]
----
include::complete/src/main/java/hello/Application.java[]
----

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/spring-boot-application.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/build_an_executable_jar_subhead.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/build_an_executable_jar_with_both.adoc[]


日志输出显示。应用程序应该在几秒钟内启动和运行。


== 测试应用

Now that the application is running, you can test it. If it is running you can load the home page on http://localhost:8080. But to give yourself more confidence that the application is working when you make changes, you want to automate the testing.

The first thing you can do is write a simple sanity check test that will fail if the application context cannot start. First add Spring Test as a dependency to your pom.xml, in the test scope. If you are using Maven:

`pom.xml`
[source,xml]
----
include::complete/pom.xml[tag=test,indent=0]
----

or if you are using Gradle:

`build.gradle`
[source,groovy]
----
include::complete/build.gradle[tag=test,indent=0]
----

Then create a test case with the `@RunWith` and `@SpringBootTest` annotations and an empty test method:

`src/test/java/hello/ApplicationTest.java`
[source,java]
----
package hello;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest
public class ApplicationTest {

    @Test
    public void contextLoads() throws Exception {
    }

}
----

The `@SpringBootTest` annotation tells Spring Boot to go and look for a main configuration class (one with `@SpringBootApplication` for instance), and use that to start a Spring application context. You can run this test in your IDE or on the command line (`mvn test` or `gradle test`) and it should pass. To convince yourself that the context is creating your controller you could add an assertion:

`src/test/java/hello/SmokeTest.java`
[source,java]
----
include::complete/src/test/java/hello/SmokeTest.java[]
----

The `@Autowired` annotation is interpreted by the Spring and the controller is injected before the test methods are run. We are using http://joel-costigliola.github.io/assertj/[AssertJ] (`assertThat()` etc.) to express the test assertions.

NOTE: A nice feature of the Spring Test support is that the application context is cached in between tests, so if you have multiple methods in a test case, or multiple test cases with the same configuration, they only incur the cost of starting the application once. You can control the cache using the {DirtiesContext}[`@DirtiesContext`] annotation.

It's nice to have a sanity check like that, but we should also write some tests that assert the behaviour of our application. To do that we could start the application up and listen for a connection like it would do in production, and then send an HTTP request and assert the response.

`src/test/java/hello/HttpRequestTest.java`
[source,java]
----
include::complete/src/test/java/hello/HttpRequestTest.java[]
----

Note the use of `webEnvironment=RANDOM_PORT` to start the server with a random port (useful to avoid conflicts in test environments), and the injection of the port with `@LocalServerPort`. Also note that Spring Boot has provided a `TestRestTemplate` for you automatically, and all you have to do is `@Autowired` it.

Another useful approach is to not start the server at all, but test only the layer below that, where Spring handles the incoming HTTP request and hands it off to your controller. That way, almost the full stack is used, and your code will be called exactly the same way as if it was processing a real HTTP request, but without the cost of starting the server. To do that we will use Spring's `MockMvc`, and we can ask for that to be injected for us by using the `@AutoConfigureMockMvc` annotation on the test case:

`src/test/java/hello/ApplicationTest.java`
[source,java]
----
include::complete/src/test/java/hello/ApplicationTest.java[]
----

In this test, the full Spring application context is started, but without the server. We can narrow down the tests to just the web layer by using `@WebMvcTest`:

`src/test/java/hello/WebLayerTest.java`
[source,java]
----
@RunWith(SpringRunner.class)
@WebMvcTest
include::complete/src/test/java/hello/WebLayerTest.java[tag=test]
----

The test assertion is the same as in the previous case, but here Spring Boot is only instantiating the web layer, not the whole context. In an application with multiple controllers you can even ask for just one to be instantiated, using, for example `@WebMvcTest(HomeController.class)`

So far, our `HomeController` is very simple and has no dependencies. We could make it more realistic by introducing an extra component to store the greeting. E.g. in a new controller:

`src/main/java/hello/GreetingController.java`
[source,java]
----
include::complete/src/main/java/hello/GreetingController.java[]
----

and then

`src/main/java/hello/GreetingService.java`
[source,java]
----
include::complete/src/main/java/hello/GreetingService.java[]
----

The service dependency will be automatically injected by Spring into the controller (because of the constructor signature). To test this controller with `@WebMvcTest` you can do this

`src/test/java/hello/WebMockTest.java`
[source,java]
----
include::complete/src/test/java/hello/WebMockTest.java[]
----

We use `@MockBean` to create and inject a mock for the `GreetingService` (if you don't do this the application context cannot start), and we set its expectations using `Mockito`.


== 总结

Congratulations! You've just developed a Spring application and tested it with JUnit and Spring `MockMvc` using Spring Boot to isolate the web layer and load a special application context.  


include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/footer.adoc[]

